// Code generated by protoc-gen-go.
// source: proto/ast.proto
// DO NOT EDIT!

/*
Package ast is a generated protocol buffer package.

It is generated from these files:
	proto/ast.proto
	proto/server.proto

It has these top-level messages:
	File
	Expression
	VariableDefinition
	TypeAlias
	Type
	TypeConstructor
	Pattern
	Label
	GetFileRequest
	GetFileResponse
	UpdateFileRequest
*/
package ast

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Type_PrimitiveType int32

const (
	Type_PRIMITIVE_TYPE_UNSPECIFIED Type_PrimitiveType = 0
	Type_INT                        Type_PrimitiveType = 1
	Type_FLOAT                      Type_PrimitiveType = 2
)

var Type_PrimitiveType_name = map[int32]string{
	0: "PRIMITIVE_TYPE_UNSPECIFIED",
	1: "INT",
	2: "FLOAT",
}
var Type_PrimitiveType_value = map[string]int32{
	"PRIMITIVE_TYPE_UNSPECIFIED": 0,
	"INT":   1,
	"FLOAT": 2,
}

func (x Type_PrimitiveType) String() string {
	return proto.EnumName(Type_PrimitiveType_name, int32(x))
}
func (Type_PrimitiveType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type File struct {
	NextRef             int64                 `protobuf:"varint,1,opt,name=next_ref,json=nextRef" json:"next_ref,omitempty"`
	Name                string                `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	TypeAliases         []*TypeAlias          `protobuf:"bytes,4,rep,name=type_aliases,json=typeAliases" json:"type_aliases,omitempty"`
	VariableDefinitions []*VariableDefinition `protobuf:"bytes,5,rep,name=variable_definitions,json=variableDefinitions" json:"variable_definitions,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *File) GetTypeAliases() []*TypeAlias {
	if m != nil {
		return m.TypeAliases
	}
	return nil
}

func (m *File) GetVariableDefinitions() []*VariableDefinition {
	if m != nil {
		return m.VariableDefinitions
	}
	return nil
}

type Expression struct {
	Ref int64 `protobuf:"varint,1,opt,name=ref" json:"ref,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Expression_EmptyValue
	//	*Expression_BoolValue
	//	*Expression_IntValue
	//	*Expression_FloatValue
	//	*Expression_StringValue
	//	*Expression_ListValue
	//	*Expression_IfValue
	//	*Expression_LambdaValue
	//	*Expression_ApplicationValue
	//	*Expression_RefValue
	//	*Expression_ExternalRefValue
	Value isExpression_Value `protobuf_oneof:"value"`
}

func (m *Expression) Reset()                    { *m = Expression{} }
func (m *Expression) String() string            { return proto.CompactTextString(m) }
func (*Expression) ProtoMessage()               {}
func (*Expression) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isExpression_Value interface {
	isExpression_Value()
}

type Expression_EmptyValue struct {
	EmptyValue int32 `protobuf:"varint,9,opt,name=empty_value,json=emptyValue,oneof"`
}
type Expression_BoolValue struct {
	BoolValue *Expression_Bool `protobuf:"bytes,2,opt,name=bool_value,json=boolValue,oneof"`
}
type Expression_IntValue struct {
	IntValue *Expression_Int `protobuf:"bytes,3,opt,name=int_value,json=intValue,oneof"`
}
type Expression_FloatValue struct {
	FloatValue *Expression_Float `protobuf:"bytes,4,opt,name=float_value,json=floatValue,oneof"`
}
type Expression_StringValue struct {
	StringValue *Expression_String `protobuf:"bytes,5,opt,name=string_value,json=stringValue,oneof"`
}
type Expression_ListValue struct {
	ListValue *Expression_List `protobuf:"bytes,6,opt,name=list_value,json=listValue,oneof"`
}
type Expression_IfValue struct {
	IfValue *Expression_If `protobuf:"bytes,7,opt,name=if_value,json=ifValue,oneof"`
}
type Expression_LambdaValue struct {
	LambdaValue *Expression_Lambda `protobuf:"bytes,10,opt,name=lambda_value,json=lambdaValue,oneof"`
}
type Expression_ApplicationValue struct {
	ApplicationValue *Expression_Application `protobuf:"bytes,11,opt,name=application_value,json=applicationValue,oneof"`
}
type Expression_RefValue struct {
	RefValue *Expression_Ref `protobuf:"bytes,12,opt,name=ref_value,json=refValue,oneof"`
}
type Expression_ExternalRefValue struct {
	ExternalRefValue *Expression_ExternalRef `protobuf:"bytes,13,opt,name=external_ref_value,json=externalRefValue,oneof"`
}

func (*Expression_EmptyValue) isExpression_Value()       {}
func (*Expression_BoolValue) isExpression_Value()        {}
func (*Expression_IntValue) isExpression_Value()         {}
func (*Expression_FloatValue) isExpression_Value()       {}
func (*Expression_StringValue) isExpression_Value()      {}
func (*Expression_ListValue) isExpression_Value()        {}
func (*Expression_IfValue) isExpression_Value()          {}
func (*Expression_LambdaValue) isExpression_Value()      {}
func (*Expression_ApplicationValue) isExpression_Value() {}
func (*Expression_RefValue) isExpression_Value()         {}
func (*Expression_ExternalRefValue) isExpression_Value() {}

func (m *Expression) GetValue() isExpression_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Expression) GetEmptyValue() int32 {
	if x, ok := m.GetValue().(*Expression_EmptyValue); ok {
		return x.EmptyValue
	}
	return 0
}

func (m *Expression) GetBoolValue() *Expression_Bool {
	if x, ok := m.GetValue().(*Expression_BoolValue); ok {
		return x.BoolValue
	}
	return nil
}

func (m *Expression) GetIntValue() *Expression_Int {
	if x, ok := m.GetValue().(*Expression_IntValue); ok {
		return x.IntValue
	}
	return nil
}

func (m *Expression) GetFloatValue() *Expression_Float {
	if x, ok := m.GetValue().(*Expression_FloatValue); ok {
		return x.FloatValue
	}
	return nil
}

func (m *Expression) GetStringValue() *Expression_String {
	if x, ok := m.GetValue().(*Expression_StringValue); ok {
		return x.StringValue
	}
	return nil
}

func (m *Expression) GetListValue() *Expression_List {
	if x, ok := m.GetValue().(*Expression_ListValue); ok {
		return x.ListValue
	}
	return nil
}

func (m *Expression) GetIfValue() *Expression_If {
	if x, ok := m.GetValue().(*Expression_IfValue); ok {
		return x.IfValue
	}
	return nil
}

func (m *Expression) GetLambdaValue() *Expression_Lambda {
	if x, ok := m.GetValue().(*Expression_LambdaValue); ok {
		return x.LambdaValue
	}
	return nil
}

func (m *Expression) GetApplicationValue() *Expression_Application {
	if x, ok := m.GetValue().(*Expression_ApplicationValue); ok {
		return x.ApplicationValue
	}
	return nil
}

func (m *Expression) GetRefValue() *Expression_Ref {
	if x, ok := m.GetValue().(*Expression_RefValue); ok {
		return x.RefValue
	}
	return nil
}

func (m *Expression) GetExternalRefValue() *Expression_ExternalRef {
	if x, ok := m.GetValue().(*Expression_ExternalRefValue); ok {
		return x.ExternalRefValue
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Expression) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Expression_OneofMarshaler, _Expression_OneofUnmarshaler, _Expression_OneofSizer, []interface{}{
		(*Expression_EmptyValue)(nil),
		(*Expression_BoolValue)(nil),
		(*Expression_IntValue)(nil),
		(*Expression_FloatValue)(nil),
		(*Expression_StringValue)(nil),
		(*Expression_ListValue)(nil),
		(*Expression_IfValue)(nil),
		(*Expression_LambdaValue)(nil),
		(*Expression_ApplicationValue)(nil),
		(*Expression_RefValue)(nil),
		(*Expression_ExternalRefValue)(nil),
	}
}

func _Expression_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Expression)
	// value
	switch x := m.Value.(type) {
	case *Expression_EmptyValue:
		b.EncodeVarint(9<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.EmptyValue))
	case *Expression_BoolValue:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BoolValue); err != nil {
			return err
		}
	case *Expression_IntValue:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IntValue); err != nil {
			return err
		}
	case *Expression_FloatValue:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FloatValue); err != nil {
			return err
		}
	case *Expression_StringValue:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringValue); err != nil {
			return err
		}
	case *Expression_ListValue:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ListValue); err != nil {
			return err
		}
	case *Expression_IfValue:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IfValue); err != nil {
			return err
		}
	case *Expression_LambdaValue:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LambdaValue); err != nil {
			return err
		}
	case *Expression_ApplicationValue:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApplicationValue); err != nil {
			return err
		}
	case *Expression_RefValue:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RefValue); err != nil {
			return err
		}
	case *Expression_ExternalRefValue:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExternalRefValue); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Expression.Value has unexpected type %T", x)
	}
	return nil
}

func _Expression_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Expression)
	switch tag {
	case 9: // value.empty_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Expression_EmptyValue{int32(x)}
		return true, err
	case 2: // value.bool_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_Bool)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_BoolValue{msg}
		return true, err
	case 3: // value.int_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_Int)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_IntValue{msg}
		return true, err
	case 4: // value.float_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_Float)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_FloatValue{msg}
		return true, err
	case 5: // value.string_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_String)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_StringValue{msg}
		return true, err
	case 6: // value.list_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_List)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_ListValue{msg}
		return true, err
	case 7: // value.if_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_If)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_IfValue{msg}
		return true, err
	case 10: // value.lambda_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_Lambda)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_LambdaValue{msg}
		return true, err
	case 11: // value.application_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_Application)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_ApplicationValue{msg}
		return true, err
	case 12: // value.ref_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_Ref)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_RefValue{msg}
		return true, err
	case 13: // value.external_ref_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_ExternalRef)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_ExternalRefValue{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Expression_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Expression)
	// value
	switch x := m.Value.(type) {
	case *Expression_EmptyValue:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.EmptyValue))
	case *Expression_BoolValue:
		s := proto.Size(x.BoolValue)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_IntValue:
		s := proto.Size(x.IntValue)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_FloatValue:
		s := proto.Size(x.FloatValue)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_StringValue:
		s := proto.Size(x.StringValue)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_ListValue:
		s := proto.Size(x.ListValue)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_IfValue:
		s := proto.Size(x.IfValue)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_LambdaValue:
		s := proto.Size(x.LambdaValue)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_ApplicationValue:
		s := proto.Size(x.ApplicationValue)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_RefValue:
		s := proto.Size(x.RefValue)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_ExternalRefValue:
		s := proto.Size(x.ExternalRefValue)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Expression_Bool struct {
	Value bool `protobuf:"varint,1,opt,name=value" json:"value,omitempty"`
}

func (m *Expression_Bool) Reset()                    { *m = Expression_Bool{} }
func (m *Expression_Bool) String() string            { return proto.CompactTextString(m) }
func (*Expression_Bool) ProtoMessage()               {}
func (*Expression_Bool) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type Expression_Int struct {
	Value int64 `protobuf:"varint,1,opt,name=value" json:"value,omitempty"`
}

func (m *Expression_Int) Reset()                    { *m = Expression_Int{} }
func (m *Expression_Int) String() string            { return proto.CompactTextString(m) }
func (*Expression_Int) ProtoMessage()               {}
func (*Expression_Int) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 1} }

type Expression_Float struct {
	Value float32 `protobuf:"fixed32,1,opt,name=value" json:"value,omitempty"`
}

func (m *Expression_Float) Reset()                    { *m = Expression_Float{} }
func (m *Expression_Float) String() string            { return proto.CompactTextString(m) }
func (*Expression_Float) ProtoMessage()               {}
func (*Expression_Float) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 2} }

type Expression_String struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *Expression_String) Reset()                    { *m = Expression_String{} }
func (m *Expression_String) String() string            { return proto.CompactTextString(m) }
func (*Expression_String) ProtoMessage()               {}
func (*Expression_String) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 3} }

type Expression_List struct {
	Values []*Expression `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *Expression_List) Reset()                    { *m = Expression_List{} }
func (m *Expression_List) String() string            { return proto.CompactTextString(m) }
func (*Expression_List) ProtoMessage()               {}
func (*Expression_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 4} }

func (m *Expression_List) GetValues() []*Expression {
	if m != nil {
		return m.Values
	}
	return nil
}

type Expression_If struct {
	Cond  *Expression `protobuf:"bytes,1,opt,name=cond" json:"cond,omitempty"`
	True  *Expression `protobuf:"bytes,2,opt,name=true" json:"true,omitempty"`
	False *Expression `protobuf:"bytes,3,opt,name=false" json:"false,omitempty"`
}

func (m *Expression_If) Reset()                    { *m = Expression_If{} }
func (m *Expression_If) String() string            { return proto.CompactTextString(m) }
func (*Expression_If) ProtoMessage()               {}
func (*Expression_If) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 5} }

func (m *Expression_If) GetCond() *Expression {
	if m != nil {
		return m.Cond
	}
	return nil
}

func (m *Expression_If) GetTrue() *Expression {
	if m != nil {
		return m.True
	}
	return nil
}

func (m *Expression_If) GetFalse() *Expression {
	if m != nil {
		return m.False
	}
	return nil
}

type Expression_Lambda struct {
	Argument *Pattern    `protobuf:"bytes,1,opt,name=argument" json:"argument,omitempty"`
	Body     *Expression `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
}

func (m *Expression_Lambda) Reset()                    { *m = Expression_Lambda{} }
func (m *Expression_Lambda) String() string            { return proto.CompactTextString(m) }
func (*Expression_Lambda) ProtoMessage()               {}
func (*Expression_Lambda) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 6} }

func (m *Expression_Lambda) GetArgument() *Pattern {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *Expression_Lambda) GetBody() *Expression {
	if m != nil {
		return m.Body
	}
	return nil
}

type Expression_Application struct {
	Left  *Expression `protobuf:"bytes,1,opt,name=left" json:"left,omitempty"`
	Right *Expression `protobuf:"bytes,2,opt,name=right" json:"right,omitempty"`
}

func (m *Expression_Application) Reset()                    { *m = Expression_Application{} }
func (m *Expression_Application) String() string            { return proto.CompactTextString(m) }
func (*Expression_Application) ProtoMessage()               {}
func (*Expression_Application) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 7} }

func (m *Expression_Application) GetLeft() *Expression {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *Expression_Application) GetRight() *Expression {
	if m != nil {
		return m.Right
	}
	return nil
}

type Expression_Ref struct {
	Ref int64 `protobuf:"varint,1,opt,name=ref" json:"ref,omitempty"`
}

func (m *Expression_Ref) Reset()                    { *m = Expression_Ref{} }
func (m *Expression_Ref) String() string            { return proto.CompactTextString(m) }
func (*Expression_Ref) ProtoMessage()               {}
func (*Expression_Ref) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 8} }

type Expression_ExternalRef struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *Expression_ExternalRef) Reset()                    { *m = Expression_ExternalRef{} }
func (m *Expression_ExternalRef) String() string            { return proto.CompactTextString(m) }
func (*Expression_ExternalRef) ProtoMessage()               {}
func (*Expression_ExternalRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 9} }

type VariableDefinition struct {
	Ref       int64       `protobuf:"varint,1,opt,name=ref" json:"ref,omitempty"`
	Label     *Label      `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	Value     *Expression `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	Arguments []*Pattern  `protobuf:"bytes,4,rep,name=arguments" json:"arguments,omitempty"`
}

func (m *VariableDefinition) Reset()                    { *m = VariableDefinition{} }
func (m *VariableDefinition) String() string            { return proto.CompactTextString(m) }
func (*VariableDefinition) ProtoMessage()               {}
func (*VariableDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *VariableDefinition) GetLabel() *Label {
	if m != nil {
		return m.Label
	}
	return nil
}

func (m *VariableDefinition) GetValue() *Expression {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *VariableDefinition) GetArguments() []*Pattern {
	if m != nil {
		return m.Arguments
	}
	return nil
}

type TypeAlias struct {
	Ref   int64  `protobuf:"varint,1,opt,name=ref" json:"ref,omitempty"`
	Label *Label `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	Type1 *Type  `protobuf:"bytes,20,opt,name=type1" json:"type1,omitempty"`
}

func (m *TypeAlias) Reset()                    { *m = TypeAlias{} }
func (m *TypeAlias) String() string            { return proto.CompactTextString(m) }
func (*TypeAlias) ProtoMessage()               {}
func (*TypeAlias) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TypeAlias) GetLabel() *Label {
	if m != nil {
		return m.Label
	}
	return nil
}

func (m *TypeAlias) GetType1() *Type {
	if m != nil {
		return m.Type1
	}
	return nil
}

type Type struct {
	Ref int64 `protobuf:"varint,1,opt,name=ref" json:"ref,omitempty"`
	// Types that are valid to be assigned to Tvalue:
	//	*Type_Primitive
	//	*Type_Compound
	//	*Type_RefType_
	Tvalue isType_Tvalue `protobuf_oneof:"tvalue"`
}

func (m *Type) Reset()                    { *m = Type{} }
func (m *Type) String() string            { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()               {}
func (*Type) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isType_Tvalue interface {
	isType_Tvalue()
}

type Type_Primitive struct {
	Primitive Type_PrimitiveType `protobuf:"varint,10,opt,name=primitive,enum=Type_PrimitiveType,oneof"`
}
type Type_Compound struct {
	Compound *Type_CompoundType `protobuf:"bytes,11,opt,name=compound,oneof"`
}
type Type_RefType_ struct {
	RefType *Type_RefType `protobuf:"bytes,12,opt,name=ref_type,json=refType,oneof"`
}

func (*Type_Primitive) isType_Tvalue() {}
func (*Type_Compound) isType_Tvalue()  {}
func (*Type_RefType_) isType_Tvalue()  {}

func (m *Type) GetTvalue() isType_Tvalue {
	if m != nil {
		return m.Tvalue
	}
	return nil
}

func (m *Type) GetPrimitive() Type_PrimitiveType {
	if x, ok := m.GetTvalue().(*Type_Primitive); ok {
		return x.Primitive
	}
	return Type_PRIMITIVE_TYPE_UNSPECIFIED
}

func (m *Type) GetCompound() *Type_CompoundType {
	if x, ok := m.GetTvalue().(*Type_Compound); ok {
		return x.Compound
	}
	return nil
}

func (m *Type) GetRefType() *Type_RefType {
	if x, ok := m.GetTvalue().(*Type_RefType_); ok {
		return x.RefType
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Type) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Type_OneofMarshaler, _Type_OneofUnmarshaler, _Type_OneofSizer, []interface{}{
		(*Type_Primitive)(nil),
		(*Type_Compound)(nil),
		(*Type_RefType_)(nil),
	}
}

func _Type_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Type)
	// tvalue
	switch x := m.Tvalue.(type) {
	case *Type_Primitive:
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Primitive))
	case *Type_Compound:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Compound); err != nil {
			return err
		}
	case *Type_RefType_:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RefType); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Type.Tvalue has unexpected type %T", x)
	}
	return nil
}

func _Type_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Type)
	switch tag {
	case 10: // tvalue.primitive
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Tvalue = &Type_Primitive{Type_PrimitiveType(x)}
		return true, err
	case 11: // tvalue.compound
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Type_CompoundType)
		err := b.DecodeMessage(msg)
		m.Tvalue = &Type_Compound{msg}
		return true, err
	case 12: // tvalue.ref_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Type_RefType)
		err := b.DecodeMessage(msg)
		m.Tvalue = &Type_RefType_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Type_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Type)
	// tvalue
	switch x := m.Tvalue.(type) {
	case *Type_Primitive:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Primitive))
	case *Type_Compound:
		s := proto.Size(x.Compound)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_RefType_:
		s := proto.Size(x.RefType)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Type_RefType struct {
	Ref int64 `protobuf:"varint,1,opt,name=ref" json:"ref,omitempty"`
}

func (m *Type_RefType) Reset()                    { *m = Type_RefType{} }
func (m *Type_RefType) String() string            { return proto.CompactTextString(m) }
func (*Type_RefType) ProtoMessage()               {}
func (*Type_RefType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type Type_OpaqueType struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Type_OpaqueType) Reset()                    { *m = Type_OpaqueType{} }
func (m *Type_OpaqueType) String() string            { return proto.CompactTextString(m) }
func (*Type_OpaqueType) ProtoMessage()               {}
func (*Type_OpaqueType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

type Type_CompoundType struct {
	X *Type `protobuf:"bytes,1,opt,name=x" json:"x,omitempty"`
	Y *Type `protobuf:"bytes,2,opt,name=y" json:"y,omitempty"`
}

func (m *Type_CompoundType) Reset()                    { *m = Type_CompoundType{} }
func (m *Type_CompoundType) String() string            { return proto.CompactTextString(m) }
func (*Type_CompoundType) ProtoMessage()               {}
func (*Type_CompoundType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 2} }

func (m *Type_CompoundType) GetX() *Type {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *Type_CompoundType) GetY() *Type {
	if m != nil {
		return m.Y
	}
	return nil
}

type TypeConstructor struct {
	Ref   int64  `protobuf:"varint,1,opt,name=ref" json:"ref,omitempty"`
	Label *Label `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
}

func (m *TypeConstructor) Reset()                    { *m = TypeConstructor{} }
func (m *TypeConstructor) String() string            { return proto.CompactTextString(m) }
func (*TypeConstructor) ProtoMessage()               {}
func (*TypeConstructor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TypeConstructor) GetLabel() *Label {
	if m != nil {
		return m.Label
	}
	return nil
}

type Pattern struct {
	Ref int64 `protobuf:"varint,1,opt,name=ref" json:"ref,omitempty"`
	// Types that are valid to be assigned to Pvalue:
	//	*Pattern_TypeConstructorValue
	//	*Pattern_LabelValue
	//	*Pattern_PatternValue
	Pvalue isPattern_Pvalue `protobuf_oneof:"pvalue"`
}

func (m *Pattern) Reset()                    { *m = Pattern{} }
func (m *Pattern) String() string            { return proto.CompactTextString(m) }
func (*Pattern) ProtoMessage()               {}
func (*Pattern) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isPattern_Pvalue interface {
	isPattern_Pvalue()
}

type Pattern_TypeConstructorValue struct {
	TypeConstructorValue *TypeConstructor `protobuf:"bytes,2,opt,name=type_constructor_value,json=typeConstructorValue,oneof"`
}
type Pattern_LabelValue struct {
	LabelValue *Label `protobuf:"bytes,3,opt,name=label_value,json=labelValue,oneof"`
}
type Pattern_PatternValue struct {
	PatternValue *Pattern `protobuf:"bytes,4,opt,name=pattern_value,json=patternValue,oneof"`
}

func (*Pattern_TypeConstructorValue) isPattern_Pvalue() {}
func (*Pattern_LabelValue) isPattern_Pvalue()           {}
func (*Pattern_PatternValue) isPattern_Pvalue()         {}

func (m *Pattern) GetPvalue() isPattern_Pvalue {
	if m != nil {
		return m.Pvalue
	}
	return nil
}

func (m *Pattern) GetTypeConstructorValue() *TypeConstructor {
	if x, ok := m.GetPvalue().(*Pattern_TypeConstructorValue); ok {
		return x.TypeConstructorValue
	}
	return nil
}

func (m *Pattern) GetLabelValue() *Label {
	if x, ok := m.GetPvalue().(*Pattern_LabelValue); ok {
		return x.LabelValue
	}
	return nil
}

func (m *Pattern) GetPatternValue() *Pattern {
	if x, ok := m.GetPvalue().(*Pattern_PatternValue); ok {
		return x.PatternValue
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Pattern) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Pattern_OneofMarshaler, _Pattern_OneofUnmarshaler, _Pattern_OneofSizer, []interface{}{
		(*Pattern_TypeConstructorValue)(nil),
		(*Pattern_LabelValue)(nil),
		(*Pattern_PatternValue)(nil),
	}
}

func _Pattern_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Pattern)
	// pvalue
	switch x := m.Pvalue.(type) {
	case *Pattern_TypeConstructorValue:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TypeConstructorValue); err != nil {
			return err
		}
	case *Pattern_LabelValue:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LabelValue); err != nil {
			return err
		}
	case *Pattern_PatternValue:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PatternValue); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Pattern.Pvalue has unexpected type %T", x)
	}
	return nil
}

func _Pattern_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Pattern)
	switch tag {
	case 2: // pvalue.type_constructor_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeConstructor)
		err := b.DecodeMessage(msg)
		m.Pvalue = &Pattern_TypeConstructorValue{msg}
		return true, err
	case 3: // pvalue.label_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Label)
		err := b.DecodeMessage(msg)
		m.Pvalue = &Pattern_LabelValue{msg}
		return true, err
	case 4: // pvalue.pattern_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Pattern)
		err := b.DecodeMessage(msg)
		m.Pvalue = &Pattern_PatternValue{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Pattern_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Pattern)
	// pvalue
	switch x := m.Pvalue.(type) {
	case *Pattern_TypeConstructorValue:
		s := proto.Size(x.TypeConstructorValue)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Pattern_LabelValue:
		s := proto.Size(x.LabelValue)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Pattern_PatternValue:
		s := proto.Size(x.PatternValue)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Label struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Label) Reset()                    { *m = Label{} }
func (m *Label) String() string            { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()               {}
func (*Label) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func init() {
	proto.RegisterType((*File)(nil), "File")
	proto.RegisterType((*Expression)(nil), "Expression")
	proto.RegisterType((*Expression_Bool)(nil), "Expression.Bool")
	proto.RegisterType((*Expression_Int)(nil), "Expression.Int")
	proto.RegisterType((*Expression_Float)(nil), "Expression.Float")
	proto.RegisterType((*Expression_String)(nil), "Expression.String")
	proto.RegisterType((*Expression_List)(nil), "Expression.List")
	proto.RegisterType((*Expression_If)(nil), "Expression.If")
	proto.RegisterType((*Expression_Lambda)(nil), "Expression.Lambda")
	proto.RegisterType((*Expression_Application)(nil), "Expression.Application")
	proto.RegisterType((*Expression_Ref)(nil), "Expression.Ref")
	proto.RegisterType((*Expression_ExternalRef)(nil), "Expression.ExternalRef")
	proto.RegisterType((*VariableDefinition)(nil), "VariableDefinition")
	proto.RegisterType((*TypeAlias)(nil), "TypeAlias")
	proto.RegisterType((*Type)(nil), "Type")
	proto.RegisterType((*Type_RefType)(nil), "Type.RefType")
	proto.RegisterType((*Type_OpaqueType)(nil), "Type.OpaqueType")
	proto.RegisterType((*Type_CompoundType)(nil), "Type.CompoundType")
	proto.RegisterType((*TypeConstructor)(nil), "TypeConstructor")
	proto.RegisterType((*Pattern)(nil), "Pattern")
	proto.RegisterType((*Label)(nil), "Label")
	proto.RegisterEnum("Type_PrimitiveType", Type_PrimitiveType_name, Type_PrimitiveType_value)
}

func init() { proto.RegisterFile("proto/ast.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 960 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x56, 0x51, 0x73, 0xda, 0x46,
	0x10, 0x46, 0x80, 0x40, 0x5a, 0xe1, 0x84, 0x9c, 0x3d, 0x0d, 0x95, 0xd3, 0x94, 0xd0, 0x4e, 0xc7,
	0x6d, 0xa6, 0xa4, 0x71, 0xda, 0x69, 0x5f, 0x6d, 0x07, 0x0a, 0x33, 0x6e, 0x4c, 0x2f, 0xd4, 0xd3,
	0x3e, 0x31, 0x02, 0x4e, 0xce, 0xcd, 0x08, 0x49, 0x95, 0x0e, 0x0f, 0xfc, 0x8a, 0xfe, 0x91, 0xfe,
	0x93, 0xfe, 0x9c, 0xbe, 0xf6, 0xa1, 0xb3, 0x77, 0x27, 0x21, 0x19, 0x5e, 0xf2, 0x76, 0xb7, 0xdf,
	0xf7, 0xed, 0xee, 0xed, 0x2e, 0x2b, 0xe0, 0x71, 0x9c, 0x44, 0x22, 0x7a, 0xe5, 0xa5, 0xa2, 0x2f,
	0x4f, 0xbd, 0xbf, 0x0d, 0xa8, 0x0f, 0x79, 0xc0, 0xc8, 0xa7, 0x60, 0x85, 0x6c, 0x23, 0x66, 0x09,
	0xf3, 0x3b, 0x46, 0xd7, 0x38, 0xab, 0xd1, 0x26, 0xde, 0x29, 0xf3, 0x09, 0x81, 0x7a, 0xe8, 0xad,
	0x58, 0xa7, 0xda, 0x35, 0xce, 0x6c, 0x2a, 0xcf, 0xe4, 0x5b, 0x68, 0x89, 0x6d, 0xcc, 0x66, 0x5e,
	0xc0, 0xbd, 0x94, 0xa5, 0x9d, 0x7a, 0xb7, 0x76, 0xe6, 0x9c, 0x43, 0x7f, 0xba, 0x8d, 0xd9, 0x05,
	0xda, 0xa8, 0x23, 0xb2, 0x23, 0x4b, 0xc9, 0x10, 0x4e, 0xee, 0xbd, 0x84, 0x7b, 0xf3, 0x80, 0xcd,
	0x96, 0xcc, 0xe7, 0x21, 0x17, 0x3c, 0x0a, 0xd3, 0x8e, 0x29, 0x65, 0xc7, 0xfd, 0x5b, 0x0d, 0xbe,
	0xcd, 0x31, 0x7a, 0x7c, 0xbf, 0x67, 0x4b, 0x7b, 0xff, 0x59, 0x00, 0x83, 0x4d, 0x9c, 0xb0, 0x34,
	0xe5, 0x51, 0x48, 0xda, 0x50, 0xdb, 0xe5, 0x8b, 0x47, 0xf2, 0x02, 0x1c, 0xb6, 0x8a, 0xc5, 0x76,
	0x76, 0xef, 0x05, 0x6b, 0xd6, 0xb1, 0xbb, 0xc6, 0x99, 0x39, 0xaa, 0x50, 0x90, 0xc6, 0x5b, 0xb4,
	0x91, 0xd7, 0x00, 0xf3, 0x28, 0x0a, 0x34, 0x03, 0x1f, 0xe5, 0x9c, 0xb7, 0xfb, 0x3b, 0xaf, 0xfd,
	0xcb, 0x28, 0x0a, 0x46, 0x15, 0x6a, 0x23, 0x4b, 0x49, 0xfa, 0x60, 0xf3, 0x50, 0x68, 0x45, 0x4d,
	0x2a, 0x1e, 0x17, 0x15, 0xe3, 0x50, 0x8c, 0x2a, 0xd4, 0xe2, 0xa1, 0x50, 0xfc, 0xef, 0xc1, 0xf1,
	0x83, 0xc8, 0xcb, 0x14, 0x75, 0xa9, 0x78, 0x52, 0x54, 0x0c, 0x11, 0xc6, 0xc4, 0x24, 0x4f, 0xa9,
	0x7e, 0x84, 0x56, 0x2a, 0x12, 0x1e, 0xde, 0x69, 0x99, 0x29, 0x65, 0xa4, 0x28, 0x7b, 0x2f, 0xf1,
	0x51, 0x85, 0x3a, 0x8a, 0x99, 0xbf, 0x28, 0xe0, 0x69, 0x16, 0xad, 0xb1, 0xff, 0xa2, 0x6b, 0x9e,
	0x62, 0x30, 0x1b, 0x59, 0x4a, 0xf2, 0x12, 0x2c, 0xee, 0x6b, 0x41, 0x53, 0x0a, 0x1e, 0x95, 0x1e,
	0xe4, 0x8f, 0x2a, 0xb4, 0xc9, 0xfd, 0x3c, 0xb1, 0xc0, 0x5b, 0xcd, 0x97, 0x9e, 0x16, 0xc0, 0x7e,
	0x62, 0xd7, 0x12, 0xc7, 0xc4, 0x14, 0x53, 0x09, 0x87, 0xf0, 0xc4, 0x8b, 0xe3, 0x80, 0x2f, 0x3c,
	0x6c, 0x9f, 0x56, 0x3b, 0x52, 0xfd, 0xb4, 0xa8, 0xbe, 0xd8, 0x91, 0x46, 0x15, 0xda, 0x2e, 0x68,
	0xf2, 0xfa, 0x27, 0x2c, 0x4b, 0xb7, 0xb5, 0x5f, 0x7f, 0xca, 0x30, 0x5f, 0x2b, 0x61, 0x3a, 0xe1,
	0x9f, 0x81, 0xb0, 0x8d, 0x60, 0x49, 0xe8, 0x05, 0xb3, 0x9d, 0xf0, 0x68, 0x3f, 0xf0, 0x40, 0xb3,
	0x94, 0x83, 0x36, 0xdb, 0x5d, 0xa5, 0x23, 0xf7, 0x19, 0xd4, 0x71, 0x1a, 0xc8, 0x09, 0x98, 0xca,
	0x07, 0x8e, 0x9a, 0x45, 0xd5, 0xc5, 0x3d, 0x85, 0xda, 0x38, 0x14, 0x65, 0xb0, 0x96, 0x81, 0x9f,
	0x81, 0x29, 0x9b, 0x5c, 0x86, 0xab, 0x19, 0xfc, 0x1c, 0x1a, 0xaa, 0x99, 0x65, 0xdc, 0xce, 0xf0,
	0x97, 0x50, 0xc7, 0xae, 0x91, 0x2f, 0xa0, 0x21, 0x0d, 0x69, 0xc7, 0x90, 0xbf, 0x15, 0xa7, 0x90,
	0x3e, 0xd5, 0x90, 0xcb, 0xa1, 0x3a, 0xf6, 0xc9, 0xe7, 0x50, 0x5f, 0x44, 0xe1, 0x52, 0xfa, 0x79,
	0x40, 0x94, 0x00, 0x12, 0x44, 0x92, 0xcf, 0x7c, 0x99, 0x80, 0x00, 0x79, 0x01, 0xa6, 0xef, 0x05,
	0x69, 0x36, 0xe3, 0x25, 0x86, 0x42, 0xdc, 0x1b, 0x68, 0xa8, 0x5e, 0x93, 0x2f, 0xc1, 0xf2, 0x92,
	0xbb, 0xf5, 0x8a, 0x85, 0x42, 0x87, 0xb4, 0xfa, 0x13, 0x4f, 0x60, 0x05, 0x69, 0x8e, 0x60, 0xcc,
	0x79, 0xb4, 0xdc, 0x1e, 0x8c, 0x89, 0x80, 0xfb, 0x2b, 0x38, 0x85, 0xf6, 0x23, 0x3f, 0x60, 0xbe,
	0x38, 0xf8, 0x08, 0x04, 0x30, 0xc7, 0x84, 0xdf, 0x7d, 0x10, 0x87, 0x3c, 0x2a, 0xc4, 0x7d, 0x0a,
	0x35, 0xdc, 0x5b, 0x7b, 0xdb, 0xc1, 0xfd, 0x01, 0x9c, 0x42, 0xc7, 0x71, 0xb1, 0xc5, 0x9e, 0xf8,
	0xa0, 0x0b, 0x2f, 0xcf, 0x87, 0x96, 0xdd, 0x65, 0x53, 0x77, 0xa8, 0xf7, 0x97, 0x01, 0x64, 0x7f,
	0x55, 0x1d, 0x58, 0x43, 0xcf, 0xc0, 0x0c, 0xbc, 0x39, 0x0b, 0x74, 0x92, 0x8d, 0xfe, 0x35, 0xde,
	0xa8, 0x32, 0xe2, 0x13, 0x8a, 0xab, 0xa4, 0xfc, 0x04, 0x89, 0x90, 0xaf, 0xc0, 0xce, 0x4a, 0x98,
	0x2d, 0xd7, 0x5d, 0x75, 0x77, 0x50, 0xef, 0x77, 0xb0, 0xf3, 0x95, 0xfb, 0xd1, 0x79, 0x9c, 0x82,
	0x89, 0x4b, 0xfa, 0x75, 0xe7, 0x44, 0xa2, 0xa6, 0xdc, 0xde, 0x54, 0xd9, 0x7a, 0xff, 0x56, 0xa1,
	0x8e, 0xf7, 0x03, 0x5e, 0xdf, 0x80, 0x1d, 0x27, 0x7c, 0xc5, 0x05, 0xbf, 0x57, 0xcb, 0xe0, 0xd1,
	0xf9, 0xb1, 0xd4, 0xf6, 0x27, 0x99, 0x19, 0x6f, 0xb8, 0x71, 0x72, 0x1e, 0xf9, 0x0e, 0xac, 0x45,
	0xb4, 0x8a, 0xa3, 0x75, 0xb8, 0xd4, 0x2b, 0x80, 0x28, 0xcd, 0x95, 0xb6, 0x6a, 0x49, 0xce, 0x22,
	0xdf, 0x00, 0xfe, 0xa2, 0x67, 0x98, 0x8e, 0xfe, 0xd1, 0x1f, 0x29, 0x05, 0x65, 0xbe, 0x26, 0x37,
	0x13, 0x75, 0x74, 0x4f, 0xa1, 0xa9, 0xad, 0x07, 0xda, 0xde, 0x05, 0xb8, 0x89, 0xbd, 0x3f, 0xd7,
	0x32, 0xab, 0xbc, 0xc3, 0xc6, 0xae, 0xc3, 0xee, 0x4f, 0xd0, 0x2a, 0xa6, 0x41, 0x8e, 0xc1, 0xd8,
	0xe8, 0x11, 0xd4, 0x55, 0x31, 0x36, 0x68, 0xcc, 0xe6, 0x38, 0x33, 0x6e, 0x7b, 0x57, 0x70, 0x54,
	0x7a, 0x34, 0x79, 0x0e, 0xee, 0x84, 0x8e, 0x7f, 0x19, 0x4f, 0xc7, 0xb7, 0x83, 0xd9, 0xf4, 0x8f,
	0xc9, 0x60, 0xf6, 0xdb, 0xbb, 0xf7, 0x93, 0xc1, 0xd5, 0x78, 0x38, 0x1e, 0xbc, 0x6d, 0x57, 0x48,
	0x13, 0x6a, 0xe3, 0x77, 0xd3, 0xb6, 0x41, 0x6c, 0x30, 0x87, 0xd7, 0x37, 0x17, 0xd3, 0x76, 0xf5,
	0xd2, 0x82, 0x86, 0x50, 0x13, 0x76, 0x01, 0x8f, 0xd1, 0xcb, 0x55, 0x14, 0xa6, 0x22, 0x59, 0x2f,
	0x44, 0x94, 0x7c, 0x6c, 0x57, 0x7b, 0xff, 0x18, 0xd0, 0xd4, 0x93, 0x72, 0x40, 0x3b, 0x82, 0x4f,
	0xe4, 0x87, 0x7b, 0xb1, 0x8b, 0xf0, 0xe0, 0x4b, 0xf8, 0x20, 0xfe, 0xa8, 0x42, 0x4f, 0x44, 0xd9,
	0xa4, 0x96, 0xec, 0xd7, 0xe0, 0xc8, 0x80, 0xa5, 0xcf, 0xa2, 0xce, 0x05, 0xbf, 0x6c, 0x12, 0x54,
	0xd4, 0x57, 0x70, 0x14, 0xab, 0x8c, 0x4a, 0x5f, 0xc4, 0x7c, 0xa2, 0x47, 0x15, 0xda, 0xd2, 0x04,
	0x29, 0xc0, 0x82, 0xc4, 0xaa, 0x20, 0xa7, 0x60, 0x4a, 0x8f, 0x87, 0xda, 0x36, 0x6f, 0xc8, 0x3f,
	0x31, 0x6f, 0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x46, 0x34, 0xb7, 0x16, 0xd7, 0x08, 0x00, 0x00,
}
